// Copyright (c) 2017 Copyright Holder All Rights Reserved.

#include "suffixTree.h"

#include <algorithm>
#include <random>
#include <string>
#include <vector>
#include <utility>

#include "gtest/gtest.h"

using testing::Test;

#define NUM_TEST_CASES 10000
#define RANDOM_STRING_SIZE 100

TEST(GeneralizedSuffixTreeSanityTest, SimpleTest) {
    std::string s1 = "youodsa";
    std::string s2 = "dsadasf";

    std::string input = s1 + "$" + s2 + "#";

    int firstLength = s1.length();
    int secondLength = s2.length();

    // Creating initial suffixTree.
    suffixTree tree(0, 0, -1);
    // Build the generalized suffix tree
    tree.buildGeneralizedSuffixTree(input, firstLength, secondLength);
    auto vec = tree.findLongestCommonSubstr();
    ASSERT_EQ(vec.size(), 1);
    EXPECT_EQ(vec[0], "dsa");
    tree.clearTree();
}

/* Sanity check for genralized suffix tree based matching.
 * Does NUM_TEST_CASES times:
 * 1) Generate random strings S1 and S2 of size RANDOM_STRING_SIZE
 * 2) Builds generalized suffix tree for S1 and S2
 * 3) Genrate random substring of S1 and S2
 * 4) Search for P1 and P2
 */
TEST(GeneralizedSuffixTreeSanityTest, SubStringMatching) {
    std::default_random_engine generator;
    // Used to build random string
    std::uniform_int_distribution<int> stringDist(97, 122);
    // Used to generate random substring size
    std::uniform_int_distribution<int> intDist(0, RANDOM_STRING_SIZE - 1);
    // Run NUM_TEST_CASES times
    for (int k = 0; k <  NUM_TEST_CASES; k++) {
        if ((0 == k % 2000) && (k != 0)) {
            cout << "**** " << k << " test cases passed ****" << endl;
        }
        std::string S1 = "";
        std::string S2 = "";
        std::string P1 = "";
        std::string P2 = "";
        std::string input = "";

        char currChar;
        bool found = false;

        // randomly generate the start and end position for substring
        int begin;
        int end;

        // generate a random string T of size RANDOM_STRING_SIZE
        for (int i = 0; i < RANDOM_STRING_SIZE; i++) {
            currChar = static_cast<char>(stringDist(generator));
            while ((currChar <= '`') && (currChar >= '[')) {
                currChar = static_cast<char>(stringDist(generator));
            }
            S1 += currChar;

            currChar = static_cast<char>(stringDist(generator));
            while ((currChar <= '`') && (currChar >= '[')) {
                currChar = static_cast<char>(stringDist(generator));
            }
            S2 += currChar;
        }

        // Generate a random substring for S1
        begin = intDist(generator);
        end = intDist(generator);

        if (begin < end) {
            std::swap(begin, end);
        }
        P1 += S1.substr(begin, end);

        begin = intDist(generator);
        end = intDist(generator);

        if (begin < end) {
            std::swap(begin, end);
        }
        P2 += S2.substr(begin, end);

        // Build suffix tree for T
        input = S1 + "$" + S2 + "#";

        suffixTree tree(0, 0, -1);

        tree.buildGeneralizedSuffixTree(input, RANDOM_STRING_SIZE,
            RANDOM_STRING_SIZE);

        EXPECT_EQ(tree.search(P1), true) << "S1 " << S1 << " S2 "  << S2
                << " P1 " << P1 << " P2 " << P2 << endl;
        EXPECT_EQ(tree.search(P2), true) << "S1 " << S1 << " S2 "  << S2
                << " P1 " << P1 << " P2 " << P2 << endl;

        tree.clearTree();
    }
}

/* Sanity check for the length of returned longest common substring.
 * Does NUM_TEST_CASES times:
 * 1) Generate random string S with a random size less than RANDOM_STRING_SIZE
 * 2) Generate random string S1 and S2 by extending S
 * 3) Builds generalized suffix tree for S1 and S2
 * 4) Find the longest common substring of S1 and S2
 *
 * Since S1 and S2 are generated by extending S, they should have a common
 * substring of at least length |S|. This test check for the length of the
 * returned longest common substring by comparing with the length of S.
 */
TEST(LongestCommonSubstrSanityTest, ExtendSameStringTest) {
    std::default_random_engine generator;
    // Used to build random string
    std::uniform_int_distribution<int> stringDist(97, 122);
    // Used to generate random substring size
    std::uniform_int_distribution<int> intDist(0, RANDOM_STRING_SIZE - 1);

    // Run NUM_TEST_CASES times
    for (int k = 0; k <  NUM_TEST_CASES; k++) {
        if ((0 == k % 2000) && (k != 0)) {
            cout << "**** " << k << " test cases passed ****" << endl;
        }
        std::string S = "";
        std::string S1 = "";
        std::string S2 = "";
        std::string input = "";

        char currChar;

        // Randomly generate the start and end position for substring
        int randLength = intDist(generator);
        std::uniform_int_distribution<int> posDist(0, RANDOM_STRING_SIZE
            - randLength - 1);

        // Generate a random string S of random size
        for (int i = 0; i < randLength; i++) {
            currChar = static_cast<char>(stringDist(generator));
            S += currChar;
        }

        // Generate a random string S1 by extending S
        // Generate a random position for S in S1
        int randPos = posDist(generator);
        for (int i = 0; i < randPos; i++) {
            currChar = static_cast<char>(stringDist(generator));
            S1 += currChar;
        }
        S1 += S;
        for (int i = 0; i < (RANDOM_STRING_SIZE - randLength - randPos); i++) {
            currChar = static_cast<char>(stringDist(generator));
            S1 += currChar;
        }

        randPos = posDist(generator);
        for (int i = 0; i < randPos; i++) {
            currChar = static_cast<char>(stringDist(generator));
            S2 += currChar;
        }
        S2 += S;
        for (int i = 0; i < (RANDOM_STRING_SIZE - randLength - randPos); i++) {
            currChar = static_cast<char>(stringDist(generator));
            S2 += currChar;
        }

        ASSERT_NE(S1.find(S), std::string::npos);
        ASSERT_NE(S2.find(S), std::string::npos);

        // Build suffix tree for T
        input = S1 + "$" + S2 + "#";

        suffixTree tree(0, 0, -1);

        tree.buildGeneralizedSuffixTree(input, RANDOM_STRING_SIZE,
            RANDOM_STRING_SIZE);

        auto result = tree.findLongestCommonSubstr();
        ASSERT_GE(result.size(), 0);
        EXPECT_GE(result[0].length(), randLength) << "found "
                << result[0].length() << " expecting " << randLength << endl;

        tree.clearTree();
    }
}

TEST(LongestCommonSubstrSanityTest, RandomStringTest) {
    // TODO(YHJ): Add this test
    std::default_random_engine generator;
    // Used to build random string
    std::uniform_int_distribution<int> stringDist(97, 122);
    // Used to generate random substring size
    std::uniform_int_distribution<int> intDist(0, RANDOM_STRING_SIZE - 1);
    // Run NUM_TEST_CASES times
    for (int k = 0; k <  NUM_TEST_CASES; k++) {
        if ((0 == k % 2000) && (k != 0)) {
            cout << "**** " << k << " test cases passed ****" << endl;
        }
        std::string S1 = "";
        std::string S2 = "";
        std::string input = "";
        std::vector<std::string> LCS;
        std::vector<std::string> result;

        char currChar;

        int firstLength;
        int secondLength;
        int maxLength = 0;

        // generate a random string T of size RANDOM_STRING_SIZE
        for (int i = 0; i < RANDOM_STRING_SIZE; i++) {
            currChar = static_cast<char>(stringDist(generator));
            while ((currChar <= '`') && (currChar >= '[')) {
                currChar = static_cast<char>(stringDist(generator));
            }
            S1 += currChar;

            currChar = static_cast<char>(stringDist(generator));
            while ((currChar <= '`') && (currChar >= '[')) {
                currChar = static_cast<char>(stringDist(generator));
            }
            S2 += currChar;
        }

        input = S1 + "$" + S2 + "#";

        firstLength = S1.length();
        secondLength = S2.length();

        suffixTree tree(0, 0, -1);

        tree.buildGeneralizedSuffixTree(input, RANDOM_STRING_SIZE,
            RANDOM_STRING_SIZE);

        result = tree.findLongestCommonSubstr();
        // O(m^2n^2) naive method of finding LCS, note this method generate
        // duplicate substrings.
        for (int i = 0; i < firstLength; i++) {
            for (int j = i; j < firstLength; j++) {
                std::string substr = "";
                if (j == i) {
                    substr = S1[i];
                } else {
                 substr = S1.substr(i, j - i + 1);
                }
                if (S2.find(substr) != std::string::npos) {
                    if (substr.length() > maxLength) {
                        maxLength = substr.length();
                        LCS.clear();
                        LCS.push_back(substr);
                    } else if (substr.length() == maxLength) {
                        LCS.push_back(substr);
                    } else {
                    }
                }
            }
        }

        std::sort(LCS.begin(), LCS.end());
        // Remove duplicate strings
        auto it = std::unique(LCS.begin(), LCS.end());
        LCS.resize(std::distance(LCS.begin(), it));

        ASSERT_EQ(result.size(), LCS.size())
            << "S1: " << S1 << " S2: " << S2 << "\n";
        std::sort(result.begin(), result.end());

        for (int i = 0; i < result.size(); i++) {
            EXPECT_EQ(LCS[i].compare(result[i]), 0);
        }

        tree.clearTree();
    }
}

int main(int argc, char** argv) {
    testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
